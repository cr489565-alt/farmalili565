<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>üì¶ Inventario - Farmacia Lili √ìptica (IndexedDB)</title>

<!-- Librer√≠as externas (CDN) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>

<style>
/* --- estilos (adaptados de tu versi√≥n original) --- */
* { box-sizing: border-box; }
body { font-family: system-ui, sans-serif; background:#f9fafb; color:#1f2937; margin:0; padding:0; }
header { background:#2563eb; color: white; padding: 30px; font-size: 26px; font-weight: bold; text-align: center; position: relative; box-shadow: 0 2px 10px rgba(0,0,0,0.2); }
header img { position:absolute; left:10px; top:50%; transform:translateY(-50%); width:150px; height:100px; border-radius:25px; border: 2px solid #e5e7eb; }
main { padding:16px; display:flex; flex-direction:column; gap:16px; }
.main-menu { display:flex; gap:12px; background:#ffffff; padding:10px 16px; position:sticky; top:0; z-index:1000; border-bottom:1px solid #e5e7eb; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }

function getStockClass(stock = 0, min = 0) {
  if (stock <= min + 10) return 'stock-rojo';
  if (stock > min + 10 && stock <= min + 20) return 'stock-amarillo';
  return 'stock-verde';
}
function getCaducidadClass(fechaCad) {
  if (!fechaCad) return '';
  const hoy = new Date();
  const cad = new Date(fechaCad);
  const diff = (cad - hoy) / (1000 * 60 * 60 * 24);
  if (diff <= 20) return 'cad-rojo';
  if (diff > 20 && diff <= 50) return 'cad-amarillo';
  return 'cad-verde';
}
function getCategoriaClass(cat) {
  switch (cat) {
    case 'Farmacia': return 'categoria-farmacia';
    case 'Tienda': return 'categoria-tienda';
    case 'Antibi√≥tico': return 'categoria-antibiotico';
    case 'Papeler√≠a': return 'categoria-papeleria';
    case 'Proveedores': return 'categoria-proveedores';
    case 'Beb√©s': return 'categoria-bebes';
    case 'Tecnolog√≠a': return 'categoria-tecnologia';
    case 'Accesorios': return 'categoria-accesorios';
    default: return '';
  }
}

/* ===============================
   Operaciones sobre productos
   =============================== */
async function guardarProductoLocal(producto) {
  // validaci√≥n ligera
  if (!producto || !producto.codigo) return;
  // En antibi√≥ticos, exigir lote y caducidad
  if (producto.categoria === 'Antibi√≥tico' && (!producto.lote || !producto.caducidad)) {
    alert('‚ùå Para antibi√≥ticos, los campos Lote y Caducidad son obligatorios');
    return;
  }
  await idbPut(STORE_PRODUCTOS, producto);
  // registrar en historial como 'producto_actualizado' o 'producto_creado'
  await idbPut(STORE_HISTORIAL, { accion: 'producto_guardado', producto: producto, usuario: usuarioActivo, fecha: new Date().toISOString() });
  // notificar otros tabs/p√°ginas
  broadcastUpdate('producto_actualizado', { codigo: producto.codigo });
  await renderTablasInventario();
  await actualizarEstadisticas();
}

async function eliminarProductoLocal(codigo) {
  if (!confirm(`¬øEliminar producto ${codigo}?`)) return;
  await idbDelete(STORE_PRODUCTOS, codigo);
  await idbPut(STORE_HISTORIAL, { accion: 'producto_eliminado', codigo, usuario: usuarioActivo, fecha: new Date().toISOString() });
  broadcastUpdate('producto_eliminado', { codigo });
  await renderTablasInventario();
  await actualizarEstadisticas();
}

async function obtenerProducto(codigo) {
  return await idbGet(STORE_PRODUCTOS, codigo);
}

/* ===============================
   Renderizado de tablas
   =============================== */
async function renderTablasInventario() {
  // leer todos los productos desde IndexedDB
  const productos = await idbGetAll(STORE_PRODUCTOS);
  const searchTerm = document.getElementById('searchBar').value.trim().toLowerCase();

  // filtrar no proveedores para tabla general
  const productosNoProveedores = productos.filter(p => p.categoria !== 'Proveedores');

  const productosFiltrados = productosNoProveedores.filter(p =>
    (!searchTerm) ||
    (p.nombre && p.nombre.toLowerCase().includes(searchTerm)) ||
    (p.codigo && p.codigo.toLowerCase().includes(searchTerm))
  );

  const antibioticosFiltrados = productos.filter(p => p.categoria === 'Antibi√≥tico' && (
    !searchTerm || (p.nombre && p.nombre.toLowerCase().includes(searchTerm)) || (p.codigo && p.codigo.toLowerCase().includes(searchTerm))
  ));

  const proveedoresFiltrados = productos.filter(p => p.categoria === 'Proveedores' && (
    !searchTerm || (p.nombre && p.nombre.toLowerCase().includes(searchTerm)) || (p.codigo && p.codigo.toLowerCase().includes(searchTerm))
  ));

  // limpiar tablas
  tablaGeneralBody.innerHTML = '';
  tablaAntibioticosBody.innerHTML = '';
  tablaProveedoresBody.innerHTML = '';

  productosFiltrados.forEach((p, idx) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="numeracion">${idx + 1}</td>
      <td>${p.codigo || 'ND'}</td>
      <td>${p.nombre || 'ND'}</td>
      <td class="precio-verde">${p.precio ? '$' + p.precio : 'ND'}</td>
      <td>${p.lote || 'ND'}</td>
      <td class="${getStockClass(p.stock, p.stockMin)}">${p.stock ?? 'ND'}</td>
      <td class="stockmin-rojo">${p.stockMin ?? 'ND'}</td>
      <td class="entradas-azul">${p.entradas ?? 'ND'}</td>
      <td class="${getCategoriaClass(p.categoria)}">${p.categoria ?? 'ND'}</td>
      <td class="${p.categoria === 'Antibi√≥tico' ? getCaducidadClass(p.caducidad) : ''}">${p.categoria === 'Antibi√≥tico' ? (p.caducidad || 'ND') : 'ND'}</td>
      <td>
        ${userType === 'admin' ? `<button class="btn btn-edit" onclick='editarProducto("${encodeURIComponent(JSON.stringify(p))}")'>‚úèÔ∏è</button>
        <button class="btn btn-del" onclick='eliminarProductoLocal("${p.codigo}")'>üóëÔ∏è</button>` : ''}
      </td>
    `;
    tablaGeneralBody.appendChild(tr);
  });

  antibioticosFiltrados.forEach((p, idx) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="numeracion">${idx + 1}</td>
      <td>${p.nombre || 'ND'}</td>
      <td>${p.codigo || 'ND'}</td>
      <td class="precio-verde">${p.precio ? '$' + p.precio : 'ND'}</td>
      <td>${p.lote || 'ND'}</td>
      <td class="${getStockClass(p.stock,p.stockMin)}">${p.stock ?? 'ND'}</td>
      <td class="stockmin-rojo">${p.stockMin ?? 'ND'}</td>
      <td class="entradas-azul">${p.entradas ?? 'ND'}</td>
      <td class="${getCategoriaClass(p.categoria)}">${p.categoria ?? 'ND'}</td>
      <td class="${getCaducidadClass(p.caducidad)}">${p.caducidad ?? 'ND'}</td>
      <td>
        ${userType === 'admin' ? `<button class="btn btn-edit" onclick='editarProducto("${encodeURIComponent(JSON.stringify(p))}")'>‚úèÔ∏è</button>
        <button class="btn btn-del" onclick='eliminarProductoLocal("${p.codigo}")'>üóëÔ∏è</button>` : ''}
      </td>
    `;
    tablaAntibioticosBody.appendChild(tr);
  });

  proveedoresFiltrados.forEach((p, idx) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="numeracion">${idx + 1}</td>
      <td>${p.nombre || 'ND'}</td>
      <td>${p.codigo || 'ND'}</td>
      <td class="${getCategoriaClass(p.categoria)}">${p.categoria || 'ND'}</td>
      <td>
        ${userType === 'admin' ? `<button class="btn btn-edit" onclick='editarProducto("${encodeURIComponent(JSON.stringify(p))}")'>‚úèÔ∏è</button>
        <button class="btn btn-del" onclick='eliminarProductoLocal("${p.codigo}")'>üóëÔ∏è</button>` : ''}
      </td>
    `;
    tablaProveedoresBody.appendChild(tr);
  });
}

/* ===============================
   Entradas (historial de entradas)
   =============================== */
async function registrarEntrada(codigo, descripcion, stockAnterior, entradas) {
  const nuevaEntrada = {
    codigo,
    descripcion,
    stockAnterior,
    entradas,
    nuevoStock: stockAnterior + entradas,
    cajero: usuarioActivo,
    fechaHora: new Date().toISOString()
  };
  await idbPut(STORE_ENTRADAS, nuevaEntrada); // se guarda con key autoIncrement
  await idbPut(STORE_HISTORIAL, { accion: 'entrada', entrada: nuevaEntrada, usuario: usuarioActivo, fecha: new Date().toISOString() });
  broadcastUpdate('entrada', { codigo, cantidad: entradas });
  await renderTablaEntradas();
}

async function renderTablaEntradas() {
  const entradas = await idbGetAll(STORE_ENTRADAS);
  tablaEntradasBody.innerHTML = '';
  entradas.forEach((entrada, i) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="numeracion">${i + 1}</td>
      <td>${entrada.codigo}</td>
      <td>${entrada.descripcion}</td>
      <td>${entrada.stockAnterior}</td>
      <td class="entradas-azul">${entrada.entradas}</td>
      <td>${entrada.nuevoStock}</td>
      <td>${entrada.cajero}</td>
      <td>${new Date(entrada.fechaHora).toLocaleString()}</td>
    `;
    tablaEntradasBody.appendChild(tr);
  });
}

/* ===============================
   Actualizaci√≥n de stock por entradas/ventas/reembolsos
   =============================== */
async function actualizarStockConEntradas(codigo, cantidad) {
  const producto = await idbGet(STORE_PRODUCTOS, codigo);
  if (!producto) { alert('‚ùå Producto no encontrado. Verifique el c√≥digo.'); return; }
  const stockAnterior = producto.stock || 0;
  producto.stock = stockAnterior + cantidad;
  producto.entradas = (producto.entradas || 0) + cantidad;
  await idbPut(STORE_PRODUCTOS, producto);
  await registrarEntrada(codigo, producto.nombre, stockAnterior, cantidad);
  await renderTablasInventario();
  await actualizarEstadisticas();
}

async function actualizarStockConVentas(ventaData) {
  // ventaData.productos = [{ codigo, cantidad }, ...]
  for (const item of ventaData.productos) {
    const producto = await idbGet(STORE_PRODUCTOS, item.codigo);
    if (producto) {
      producto.stock = Math.max(0, (producto.stock || 0) - item.cantidad);
      producto.entradas = Math.max(0, (producto.entradas || 0) - item.cantidad);
      await idbPut(STORE_PRODUCTOS, producto);
    }
  }
  await idbPut(STORE_HISTORIAL, { accion: 'venta', venta: ventaData, usuario: ventaData.usuario || 'venta', fecha: new Date().toISOString() });
  broadcastUpdate('venta', ventaData);
  await renderTablasInventario();
  await actualizarEstadisticas();
}

async function actualizarStockConReembolsos(ventaData, codigosReemb, cantidadesReemb) {
  for (let i = 0; i < codigosReemb.length; i++) {
    const codigo = codigosReemb[i];
    const cantidad = cantidadesReemb[i];
    const producto = await idbGet(STORE_PRODUCTOS, codigo);
    if (producto) {
      producto.stock = (producto.stock || 0) + cantidad;
      producto.entradas = (producto.entradas || 0) + cantidad;
      await idbPut(STORE_PRODUCTOS, producto);
    }
  }
  await idbPut(STORE_HISTORIAL, { accion: 'reembolso', codigos: codigosReemb, cantidades: cantidadesReemb, usuario: usuarioActivo, fecha: new Date().toISOString() });
  broadcastUpdate('reembolso', { codigos: codigosReemb, cantidades: cantidadesReemb });
  await renderTablasInventario();
  await actualizarEstadisticas();
}

/* ===============================
   CSV upload (robusta)
   =============================== */
async function subirCSV(event) {
  const file = event.target.files[0];
  if (!file) return;
  document.getElementById('uploadContainer').classList.remove('oculto');
  document.getElementById('progressBar').style.width = '0%';
  document.getElementById('statusMessage').style.display = 'none';
  const reader = new FileReader();
  reader.onload = async function(e) {
    // progreso simulado
    let progress = 0;
    const interval = setInterval(() => {
      progress += 10;
      document.getElementById('progressBar').style.width = progress + '%';
      if (progress >= 100) clearInterval(interval);
    }, 150);

    setTimeout(async () => {
      try {
        const raw = e.target.result;
        const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
        if (lines.length === 0) throw new Error('Archivo vac√≠o');

        // detect headers
        const first = lines[0].split(',').map(h => h.toLowerCase().trim());
        const known = ['codigo','c√≥digo','nombre','descripcion','descripci√≥n','precio','lote','stock','stockmin','stock m√≠nimo','entradas','categoria','categor√≠a','caducidad','fecha','fecha de caducidad'];
        const hasHeaders = first.some(h => known.includes(h));

        const headerMap = {};
        if (hasHeaders) {
          first.forEach((h, idx) => {
            const clean = h.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
            if (clean.includes('codigo')) headerMap.codigo = idx;
            else if (clean.includes('nombre') || clean.includes('descripcion')) headerMap.nombre = idx;
            else if (clean.includes('precio')) headerMap.precio = idx;
            else if (clean.includes('lote')) headerMap.lote = idx;
            else if (clean.includes('stock') && clean.includes('min')===false) headerMap.stock = idx;
            else if (clean.includes('minimo') || clean.includes('min')) headerMap.stockMin = idx;
            else if (clean.includes('entradas')) headerMap.entradas = idx;
            else if (clean.includes('categoria')) headerMap.categoria = idx;
            else if (clean.includes('caducidad') || clean.includes('fecha')) headerMap.caducidad = idx;
          });
        }

        const start = hasHeaders ? 1 : 0;
        let cambios = 0;
        for (let i = start; i < lines.length; i++) {
          const parts = lines[i].split(',');
          // ensure length
          while (parts.length < 9) parts.push('');
          const producto = {
            codigo: headerMap.codigo !== undefined ? parts[headerMap.codigo].trim() : (parts[0]||'').trim(),
            nombre: headerMap.nombre !== undefined ? parts[headerMap.nombre].trim() : (parts[1]||'').trim(),
            precio: headerMap.precio !== undefined ? parseFloat(parts[headerMap.precio]) || 0 : parseFloat(parts[2]) || 0,
            lote: headerMap.lote !== undefined ? parts[headerMap.lote].trim() : (parts[3]||'').trim(),
            stock: headerMap.stock !== undefined ? parseInt(parts[headerMap.stock]) || 0 : parseInt(parts[4]) || 0,
            stockMin: headerMap.stockMin !== undefined ? parseInt(parts[headerMap.stockMin]) || 0 : parseInt(parts[5]) || 0,
            entradas: headerMap.entradas !== undefined ? parseInt(parts[headerMap.entradas]) || 0 : parseInt(parts[6]) || 0,
            categoria: headerMap.categoria !== undefined ? parts[headerMap.categoria].trim() : (parts[7]||'').trim(),
            caducidad: headerMap.caducidad !== undefined ? parts[headerMap.caducidad].trim() : (parts[8]||'').trim()
          };
          if (!producto.codigo) continue; // saltar filas sin c√≥digo
          await idbPut(STORE_PRODUCTOS, producto);
          cambios++;
        }

        await idbPut(STORE_HISTORIAL, { accion: 'import_csv', cantidad: cambios, usuario: usuarioActivo, fecha: new Date().toISOString() });
        broadcastUpdate('import_csv', { cambios });

        document.getElementById('statusMessage').textContent = `‚úÖ Inventario cargado correctamente (${cambios} filas)`;
        document.getElementById('statusMessage').className = 'status-message status-success';
        document.getElementById('statusMessage').style.display = 'block';

        await renderTablasInventario();
        await actualizarEstadisticas();
      } catch (err) {
        console.error(err);
        document.getElementById('statusMessage').textContent = '‚ùå Error cargando CSV: ' + (err.message || err);
        document.getElementById('statusMessage').className = 'status-message status-error';
        document.getElementById('statusMessage').style.display = 'block';
      } finally {
        setTimeout(()=> document.getElementById('uploadContainer').classList.add('oculto'), 2000);
      }
    }, 800);
  };
  reader.readAsText(file);
}

/* ===============================
   Eliminar todo inventario
   (vac√≠a objetos stores)
   =============================== */
async function eliminarInventario() {
  if (!confirm('‚ö†Ô∏è ¬øSeguro que quieres eliminar TODO el inventario y entradas?')) return;
  // Re-crear la base para limpiar
  const req = indexedDB.deleteDatabase(DB_NAME);
  req.onsuccess = async () => {
    db = null;
    await openDB();
    await idbPut(STORE_HISTORIAL, { accion: 'eliminar_inventario_total', usuario: usuarioActivo, fecha: new Date().toISOString() });
    broadcastUpdate('eliminar_inventario_total', {});
    await renderTablasInventario();
    await renderTablaEntradas();
    await actualizarEstadisticas();
    alert('üóëÔ∏è Inventario eliminado');
  };
  req.onerror = (e) => alert('Error al eliminar DB: ' + e.target.error);
}

/* ===============================
   Exportar CSV / PDF por categor√≠a
   =============================== */
async function descargarInventarioPorCategoria() {
  const categorias = ['general', 'Antibi√≥tico', 'Papeler√≠a', 'Tienda', 'Farmacia', 'Proveedores', 'Beb√©s', 'Tecnolog√≠a', 'Accesorios'];
  const categoria = prompt(`Ingrese la categor√≠a a descargar:\n${categorias.join('\n')}`);
  if (!categoria) return;
  const productos = await idbGetAll(STORE_PRODUCTOS);
  let seleccion = [];
  if (categoria.toLowerCase() === 'general') seleccion = productos;
  else seleccion = productos.filter(p => (p.categoria || '').toLowerCase() === categoria.toLowerCase());
  if (!seleccion.length) return alert('‚ùå No hay productos en esa categor√≠a.');
  let csv = 'C√≥digo,Nombre,Precio,Stock,StockMin,Entradas,Categor√≠a,Caducidad,Lote\n';
  seleccion.forEach(i => {
    csv += `${i.codigo || ''},${i.nombre || ''},${i.precio || 0},${i.stock || 0},${i.stockMin || 0},${i.entradas || 0},${i.categoria || ''},${i.caducidad || ''},${i.lote || ''}\n`;
  });
  const blob = new Blob([csv], { type: 'text/csv' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = `inventario_${categoria}.csv`;
  link.click();
}

async function descargarPDFPorCategoria() {
  const categorias = ['general', 'Antibi√≥tico', 'Papeler√≠a', 'Tienda', 'Farmacia', 'Proveedores', 'Beb√©s', 'Tecnolog√≠a', 'Accesorios'];
  const categoria = prompt(`Ingrese la categor√≠a para descargar PDF:\n${categorias.join('\n')}`);
  if (!categoria) return;
  const productos = await idbGetAll(STORE_PRODUCTOS);
  let seleccion = [];
  if (categoria.toLowerCase() === 'general') seleccion = productos;
  else seleccion = productos.filter(p => (p.categoria || '').toLowerCase() === categoria.toLowerCase());
  if (!seleccion.length) return alert('‚ùå No hay productos en esa categor√≠a.');

  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();
  doc.setFontSize(18);
  doc.text(`Inventario - ${categoria}`, 14, 15);

  // crear tabla 'in memory'
  const tempTable = document.createElement('table');
  tempTable.id = 'tempTableForPDF';
  tempTable.style.display = 'none';
  const head = '<thead><tr><th>Nombre</th><th>C√≥digo</th><th>Precio</th><th>Stock</th><th>Stock M√≠nimo</th><th>Entradas</th><th>Categor√≠a</th><th>Caducidad</th></tr></thead>';
  let body = '<tbody>';
  seleccion.forEach(p => {
    body += `<tr><td>${p.nombre || ''}</td><td>${p.codigo || ''}</td><td>${p.precio || 0}</td><td>${p.stock || 0}</td><td>${p.stockMin || 0}</td><td>${p.entradas || 0}</td><td>${p.categoria || ''}</td><td>${p.caducidad || ''}</td></tr>`;
  });
  body += '</tbody>';
  tempTable.innerHTML = head + body;
  document.body.appendChild(tempTable);

  doc.autoTable({ html: '#tempTableForPDF', startY: 25 });
  document.body.removeChild(tempTable);
  doc.save(`inventario_${categoria}.pdf`);
}

/* ===============================
   Estad√≠sticas
   =============================== */
async function actualizarEstadisticas() {
  const productos = await idbGetAll(STORE_PRODUCTOS);
  const totalProductos = productos.length;
  const totalStock = productos.reduce((sum, p) => sum + ((p.stock) || 0), 0);
  const categorias = [...new Set(productos.map(p => p.categoria || 'N/A'))].length;
  const bajoStock = productos.filter(p => (p.stock || 0) <= (p.stockMin || 0)).length;

  document.getElementById('totalProductos').textContent = totalProductos;
  document.getElementById('totalStock').textContent = totalStock;
  document.getElementById('categorias').textContent = categorias;
  document.getElementById('bajoStock').textContent = bajoStock;
}

/* ===============================
   Formularios y eventos UI
   =============================== */
addForm.addEventListener('submit', async (e) => {
  e.preventDefault();
  const p = {
    nombre: document.getElementById('nombre').value.trim(),
    codigo: document.getElementById('codigo').value.trim(),
    precio: parseFloat(document.getElementById('precio').value) || 0,
    lote: document.getElementById('lote').value.trim(),
    stock: parseInt(document.getElementById('stock').value) || 0,
    stockMin: parseInt(document.getElementById('stockMin').value) || 0,
    entradas: parseInt(document.getElementById('entradas').value) || 0,
    categoria: document.getElementById('categoria').value,
    caducidad: document.getElementById('caducidad').value || ''
  };

  if (p.categoria === 'Antibi√≥tico' && (!p.lote || !p.caducidad)) {
    alert('‚ùå Para antibi√≥ticos, los campos Lote y Caducidad son obligatorios');
    return;
  }

  await guardarProductoLocal(p);
  addForm.reset();
  loteCadFields.classList.add('oculto');
});

function editarProducto(encoded) {
  // recibe JSON stringifyado y URI encoded
  try {
    const p = JSON.parse(decodeURIComponent(encoded));
    productoEnEdicion = p;
    document.getElementById('nombre').value = p.nombre || '';
    document.getElementById('codigo').value = p.codigo || '';
    document.getElementById('precio').value = p.precio || '';
    document.getElementById('lote').value = p.lote || '';
    document.getElementById('stock').value = p.stock || '';
    document.getElementById('stockMin').value = p.stockMin || '';
    document.getElementById('entradas').value = p.entradas || '';
    document.getElementById('categoria').value = p.categoria || '';
    document.getElementById('caducidad').value = p.caducidad || '';

    if (p.categoria === 'Antibi√≥tico') loteCadFields.classList.remove('oculto');
    else loteCadFields.classList.add('oculto');

    adminSection.classList.remove('oculto');
    loginSection.classList.add('oculto');
    userType = 'admin';
  } catch (err) {
    console.error(err);
  }
}

categoriaSelect.addEventListener('change', (e) => {
  if (e.target.value === 'Antibi√≥tico') loteCadFields.classList.remove('oculto');
  else loteCadFields.classList.add('oculto');
});

function abrirAdmin() {
  loginSection.classList.remove('oculto');
}

loginForm.addEventListener('submit', (e) => {
  e.preventDefault();
  const pass = document.getElementById('adminPass').value;
  if (pass === 'Mariposa2026') {
    loginSection.classList.add('oculto');
    adminSection.classList.remove('oculto');
    userType = 'admin';
    renderTablasInventario();
  } else alert('‚ùå Contrase√±a incorrecta');
});

salirAdmin.addEventListener('click', () => {
  adminSection.classList.add('oculto');
  loginSection.classList.add('oculto');
  userType = 'cajero';
  renderTablasInventario();
});

function agregarEntrada() {
  document.getElementById('entradasSection').classList.remove('oculto');
  document.getElementById('generalSection').classList.add('oculto');
  document.getElementById('AntibioticosSection').classList.add('oculto');
  document.getElementById('proveedoresSection').classList.add('oculto');
  renderTablaEntradas();
}

function volverAlInventario() {
  document.getElementById('entradasSection').classList.add('oculto');
  document.getElementById('generalSection').classList.remove('oculto');
  document.getElementById('AntibioticosSection').classList.remove('oculto');
  document.getElementById('proveedoresSection').classList.remove('oculto');
}

/* Procesar entrada desde formulario */
function procesarEntrada() {
  const codigo = document.getElementById('codigoEntrada').value.trim();
  const cantidad = parseInt(document.getElementById('cantidadEntrada').value);
  if (!codigo || !cantidad) { alert('‚ùå Por favor ingrese c√≥digo y cantidad'); return; }
  actualizarStockConEntradas(codigo, cantidad);
  document.getElementById('codigoEntrada').value = '';
  document.getElementById('cantidadEntrada').value = '';
}

/* Cerrar sesi√≥n */
function cerrarSesion() {
  alert('üö™ Sesi√≥n cerrada correctamente');
  window.location.href = "index.html";
}

/* ===============================
   Escucha mensajes de BroadcastChannel / localStorage
   (para sincronizar con ven1.html / histori1.html)
   =============================== */
if (ventasChannel) {
  ventasChannel.onmessage = async (ev) => {
    const msg = ev.data;
    await handleExternalMessage(msg);
  };
}

// storage fallback (cuando otras p√°ginas usan localStorage)
window.addEventListener('storage', async (ev) => {
  if (ev.key === 'farmalili_sync' && ev.newValue) {
    try {
      const msg = JSON.parse(ev.newValue);
      await handleExternalMessage(msg);
    } catch (e) { /* ignore */ }
  }
});

async function handleExternalMessage(msg) {
  if (!msg || !msg.type) return;
  try {
    switch (msg.type) {
      case 'venta':
        // msg.payload = { productos:[{codigo,cantidad}], usuario }
        await actualizarStockConVentas(msg.payload);
        break;
      case 'reembolso':
        // payload: { codigos, cantidades }
        await actualizarStockConReembolsos(null, msg.payload.codigos, msg.payload.cantidades);
        break;
      case 'producto_actualizado':
      case 'producto_eliminado':
      case 'entrada':
      case 'import_csv':
      case 'eliminar_inventario_total':
        // simplemente refrescar tablas/estad√≠sticas
        await renderTablasInventario();
        await renderTablaEntradas();
        await actualizarEstadisticas();
        break;
      default:
        // ignorar tipos desconocidos
        break;
    }
  } catch (err) {
    console.error('Error al manejar mensaje externo', err);
  }
}

/* ===============================
   Inicializaci√≥n
   =============================== */
(async function init() {
  await openDB();
  // render inicial
  await renderTablasInventario();
  await renderTablaEntradas();
  await actualizarEstadisticas();
})();

/* ===============================
   Al final: expose algunas funciones al scope global
   (para botones dentro de innerHTML)
   =============================== */
window.editarProducto = editarProducto;
window.eliminarProductoLocal = eliminarProductoLocal;
window.procesarEntrada = procesarEntrada;
window.subirCSV = subirCSV;
window.renderTablasInventario = renderTablasInventario;
window.actualizarEstadisticas = actualizarEstadisticas;
window.renderTablaEntradas = renderTablaEntradas;
window.actualizarStockConVentas = actualizarStockConVentas;
window.actualizarStockConReembolsos = actualizarStockConReembolsos;
window.descargarInventarioPorCategoria = descargarInventarioPorCategoria;
window.descargarPDFPorCategoria = descargarPDFPorCategoria;
</script>
</body>
</html>

